{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to the NanoRv32  project\n\n\nUnder construction\n\n\nA small 32-bit implementation of the RISC-V architecture\nHighlights :\n\n\n\n\n2-stage pipeline (fetch, execute)\n\n\nlot of code is generated from a high level description\n\n\nwritten in verilog (using iverilog or Xilinx xvsim as simulator)\n\n\n\n\nStill under development :\n  - currently supporting only RV32I base instructions (no scall,sbreak,rd*)\n  - no system register implemented\n  - No interrupt support yet\n  - no RVC support (16-bit instructions)\n\n\nFPGA version available (Digilent ARTY board - Xilinx Artix7)\n\n\nProject layout\n\n\ncommon/files  # scripts to generate list of verilog files needed for the various targets (simulation, synthesis)\ncommon/generators # generator for some verilog constructs (like decoder, parameters,...)\ncommon/include    # C/asm include files (for riscv-tests for example)\ncommon/instructions # text files listing instructions, for regression testing\ncommon/linker_scripts # linker script(s) for C and asm programs\ncommon/makefile # shared Makefile\ncommon/scripts  # Miscelaneous scripts\ncommon/spec # architecture/instruction specification as Python data structures\ncommon/startup # C/asm startup file\nctests/* # Various tests written in C\ndoc_riscv # General Riscv documentation from Internet (when Internet is not available :-) )\ndocs # mkdocs source files (this documentation !) see (www.mkdocs.org)\ngenerated # various generated files from generators\nriscv-opcodes # imported github module, used to create some spec files\nriscv-test    # imported github module, various test programs for the riscv architecture\nrtl/cores     # the nanorv32 CPU files\nrtl/ips       # \"IP\" verilog models (memory, peripherals, bus interfaces,....)\nrtl/chips     # top-level and \"chip\" specific files\nsim           # directory containing the simulation launcher\nsynt/fpga     # main directory for FPGA synthesis using Xilinx Vivado\n\n\n\nInstallation\n\n\nCloning from github\n\n\nThis project uses submodules. To clone it you need to run the following commands :\n\n\ngit clone git@github.com:rbarzic/nanorv32.git\ncd nanorv32\ngit submodule update --init\n\n\n\n\nDependencies\n\n\nOn debian/Unbuntu :\n\n\nsudo apt-get install build-essential gtkwave\n\n\n\n\nIcarus verilog\n\n\nUsing  the latest version from github is recommended.\n\n\nSee https://github.com/steveicarus/iverilog\n\n\nRiscv32 gcc\n\n\nA 32-bit version of the toolchain is needed.\n\n\nTo build such a toolchain, please follws the instruction provided by the PicoRV32 project on github :\n\n\nhttps://github.com/cliffordwolf/picorv32#building-a-pure-rv32i-toolchain\n\n\nOthers\n\n\nTo run the regression on multiple cores at a time, you need GNU parallel.\n\n\nOn debian/Unbuntu :\n\n\nsudo apt-get install parallel\n\n\n\n\nSimulation  using Icarus iverilog\n\n\nRunning a test written in C\n\n\nC-based tests are located under the \n/ctests directory.\nEach test consists in one or several C files together with a configuration file \noptions.py\n.\n\n\nC compilation, RTL database compilation and simulation can be launched with the Python script \nruntest.py\n under the \n/sim directory\n\n\nUnder sim :\n\n\n#./runtest.py  <path to test directory>\n# Example :\n./runtest.py  ../ctests/gpio_toggle\n\n\n\n\n\nThe result should be\n\n\n[OK]      gcc_compile\n[OK]      icarus_rtl_build\n[OK]      icarus_rtl_elab\n[OK]      icarus_rtl_sim\n\n\n\n\n\nTo see the commands used during the C compilation, the Verilog compilation and the simulation, add the option \n-v\n to the previous command line.\n\n\nViewing the waveform\n\n\nFirst, the simulation must be launched with the -l option to turn-on the logging of all signals to a vcd file :\n\n\n# Example :\n./runtest.py  -v -l ../ctests/gpio_toggle\n\n\n\n\n\nThen  using gtkwave, you can open the vcd file that has been created in the directory of the test\n\n\ntkwave ../ctests/gpio_toggle/tb_nanorv32.vcd &\n\n\n\n\nSynthesis using Vivado\n\n\nFirst, set-up Vivado environment :\n\n\nsource /opt/Xilinx/Vivado/<vivado version>/settings64.sh\n\n\n\n\nThen, in the \n/synt/fpga directory, type :\n\n\nmake synt\n\n\n\n\nNote : The code is loaded in the ROM using the file\nsynt/fpga/code.hex. So if you want to have a specific program preloaded, you must make a link between an existing *.hex2 file to the code.hex before launching the synthesis.\n\n\nImportant note : The reset pin in mapped to the SW0 switc on the ARTY7 board. The switch must be in the position toward the board center for the reset to be released.\n\n\nUploading code using the JTAG port\n\n\nThe Nanorv32 project includes a JTAG interface (implemented using the adv_debug_sys project) that allows new CPU code to be uploaded into the FPGA without the need of a new synthesis.\n\n\nA python script for uploading code using a FT232H-based USB-to-JTAG converter is provided under \n/jtag.\n\n\nJTAG pin mapping for the Arty7 board\n\n\nThe JTAG pins are mapped on the JB connector (TCK is a special clock pin)\n\n\n\n\n\n\n\n\nPin\n\n\nFPGA pin\n\n\nArty7 JB pin name\n\n\nArty7 JB pin number\n\n\nFT232H pin\n\n\n\n\n\n\n\n\n\n\nTMS\n\n\nE15\n\n\nP1\n\n\n1\n\n\nAD3 (16)\n\n\n\n\n\n\nTDI\n\n\nE16\n\n\nP2\n\n\n2\n\n\nAD1 (14)\n\n\n\n\n\n\nTCK\n\n\nD15\n\n\nP3\n\n\n3\n\n\nAD0 (13)\n\n\n\n\n\n\nTDO\n\n\nC15\n\n\nP3\n\n\n4\n\n\nAD2 (15)\n\n\n\n\n\n\n\n\n(P5 is GND and P6 is VCC on the JB 2x6 PMOD connector)\n\n\nC Code compilation\n\n\nThe compilation of the C code to be uploaded is done using the same python script (runtest.py) as for the simulation.\nThe \n.c\n option must be used if you want to  prevent   the RTL database compilation and simulation.\n\n\n# For example (while under <top>/sim) :\n./runtest.py -c -v ../ctests/gpio_toggle_infinite\n\n\n\n\nA Intel hex file is created under the test directory test\n\n\nCode upload\n\n\nThe Intel hex file can be uploaded using the following command :\n\n\n# Example (while under <top>/sim) :\nsudo ../jtag/nanorv32_jtag_uploader.py ../ctests/gpio_toggle_infinite/gpio_toggle_infinite.ihex -r\n\n\n\n\nThe \n-r\n option is used to force a reset after the code upload so that the CPU can start executing the code right away\n\n\nNote the code update is actually very slow - This should be fix soon.\n\n\nThe pyftdi and intelhex Python modules  may need to be installed for the comman above to work properly :\n\n\nsudo pip install pyftdi intelhex\n\n\n\n\nUART output\n\n\nAn UART is implemented in the device and pins are routed to the ARTY7 onboard serial-to-usb converter.\n\n\nTo see the uart in action. compile the code with the -f option - this will replace the printf output through the verilog testbench by an output through the UART.\n\n\nSee the \n/ctest/uart_simple  verification program for an example on how to access the uart through the prinft function.\n\n\n# Example (while under <top>/sim) :\n./runtest.py    ../ctests/uart_simple -v -f -c\nsudo ../jtag/nanorv32_jtag_uploader.py ../ctests/uart_simple/uart_simple.ihex -r\n\n\n\n\n\nBaudrate is set to 38400 for this example. To visualize the UART output using miniterm.py :\n\n\nminiterm.py /dev/ttyUSB1 38400\n\n\n\n\nSimulation  using Vivado (outdated)\n\n\nCompilation\n\n\nmake xcomp\nmake xelab\n\n\n\n\nSimulation (Batch mode)\n\n\nmake xsim\n\n\n\n\nSimulation (GUI)\n\n\nmake xsim_gui\n\n\n\n\nSimulation  using Verilator\n\n\nTBD",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-the-nanorv32-project",
            "text": "Under construction  A small 32-bit implementation of the RISC-V architecture\nHighlights :   2-stage pipeline (fetch, execute)  lot of code is generated from a high level description  written in verilog (using iverilog or Xilinx xvsim as simulator)   Still under development :\n  - currently supporting only RV32I base instructions (no scall,sbreak,rd*)\n  - no system register implemented\n  - No interrupt support yet\n  - no RVC support (16-bit instructions)  FPGA version available (Digilent ARTY board - Xilinx Artix7)",
            "title": "Welcome to the NanoRv32  project"
        },
        {
            "location": "/#project-layout",
            "text": "common/files  # scripts to generate list of verilog files needed for the various targets (simulation, synthesis)\ncommon/generators # generator for some verilog constructs (like decoder, parameters,...)\ncommon/include    # C/asm include files (for riscv-tests for example)\ncommon/instructions # text files listing instructions, for regression testing\ncommon/linker_scripts # linker script(s) for C and asm programs\ncommon/makefile # shared Makefile\ncommon/scripts  # Miscelaneous scripts\ncommon/spec # architecture/instruction specification as Python data structures\ncommon/startup # C/asm startup file\nctests/* # Various tests written in C\ndoc_riscv # General Riscv documentation from Internet (when Internet is not available :-) )\ndocs # mkdocs source files (this documentation !) see (www.mkdocs.org)\ngenerated # various generated files from generators\nriscv-opcodes # imported github module, used to create some spec files\nriscv-test    # imported github module, various test programs for the riscv architecture\nrtl/cores     # the nanorv32 CPU files\nrtl/ips       # \"IP\" verilog models (memory, peripherals, bus interfaces,....)\nrtl/chips     # top-level and \"chip\" specific files\nsim           # directory containing the simulation launcher\nsynt/fpga     # main directory for FPGA synthesis using Xilinx Vivado",
            "title": "Project layout"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#cloning-from-github",
            "text": "This project uses submodules. To clone it you need to run the following commands :  git clone git@github.com:rbarzic/nanorv32.git\ncd nanorv32\ngit submodule update --init",
            "title": "Cloning from github"
        },
        {
            "location": "/#dependencies",
            "text": "On debian/Unbuntu :  sudo apt-get install build-essential gtkwave",
            "title": "Dependencies"
        },
        {
            "location": "/#icarus-verilog",
            "text": "Using  the latest version from github is recommended.  See https://github.com/steveicarus/iverilog",
            "title": "Icarus verilog"
        },
        {
            "location": "/#riscv32-gcc",
            "text": "A 32-bit version of the toolchain is needed.  To build such a toolchain, please follws the instruction provided by the PicoRV32 project on github :  https://github.com/cliffordwolf/picorv32#building-a-pure-rv32i-toolchain",
            "title": "Riscv32 gcc"
        },
        {
            "location": "/#others",
            "text": "To run the regression on multiple cores at a time, you need GNU parallel.  On debian/Unbuntu :  sudo apt-get install parallel",
            "title": "Others"
        },
        {
            "location": "/#simulation-using-icarus-iverilog",
            "text": "",
            "title": "Simulation  using Icarus iverilog"
        },
        {
            "location": "/#running-a-test-written-in-c",
            "text": "C-based tests are located under the  /ctests directory.\nEach test consists in one or several C files together with a configuration file  options.py .  C compilation, RTL database compilation and simulation can be launched with the Python script  runtest.py  under the  /sim directory  Under sim :  #./runtest.py  <path to test directory>\n# Example :\n./runtest.py  ../ctests/gpio_toggle  The result should be  [OK]      gcc_compile\n[OK]      icarus_rtl_build\n[OK]      icarus_rtl_elab\n[OK]      icarus_rtl_sim  To see the commands used during the C compilation, the Verilog compilation and the simulation, add the option  -v  to the previous command line.",
            "title": "Running a test written in C"
        },
        {
            "location": "/#viewing-the-waveform",
            "text": "First, the simulation must be launched with the -l option to turn-on the logging of all signals to a vcd file :  # Example :\n./runtest.py  -v -l ../ctests/gpio_toggle  Then  using gtkwave, you can open the vcd file that has been created in the directory of the test  tkwave ../ctests/gpio_toggle/tb_nanorv32.vcd &",
            "title": "Viewing the waveform"
        },
        {
            "location": "/#synthesis-using-vivado",
            "text": "First, set-up Vivado environment :  source /opt/Xilinx/Vivado/<vivado version>/settings64.sh  Then, in the  /synt/fpga directory, type :  make synt  Note : The code is loaded in the ROM using the file\nsynt/fpga/code.hex. So if you want to have a specific program preloaded, you must make a link between an existing *.hex2 file to the code.hex before launching the synthesis.  Important note : The reset pin in mapped to the SW0 switc on the ARTY7 board. The switch must be in the position toward the board center for the reset to be released.",
            "title": "Synthesis using Vivado"
        },
        {
            "location": "/#uploading-code-using-the-jtag-port",
            "text": "The Nanorv32 project includes a JTAG interface (implemented using the adv_debug_sys project) that allows new CPU code to be uploaded into the FPGA without the need of a new synthesis.  A python script for uploading code using a FT232H-based USB-to-JTAG converter is provided under  /jtag.",
            "title": "Uploading code using the JTAG port"
        },
        {
            "location": "/#jtag-pin-mapping-for-the-arty7-board",
            "text": "The JTAG pins are mapped on the JB connector (TCK is a special clock pin)     Pin  FPGA pin  Arty7 JB pin name  Arty7 JB pin number  FT232H pin      TMS  E15  P1  1  AD3 (16)    TDI  E16  P2  2  AD1 (14)    TCK  D15  P3  3  AD0 (13)    TDO  C15  P3  4  AD2 (15)     (P5 is GND and P6 is VCC on the JB 2x6 PMOD connector)",
            "title": "JTAG pin mapping for the Arty7 board"
        },
        {
            "location": "/#c-code-compilation",
            "text": "The compilation of the C code to be uploaded is done using the same python script (runtest.py) as for the simulation.\nThe  .c  option must be used if you want to  prevent   the RTL database compilation and simulation.  # For example (while under <top>/sim) :\n./runtest.py -c -v ../ctests/gpio_toggle_infinite  A Intel hex file is created under the test directory test",
            "title": "C Code compilation"
        },
        {
            "location": "/#code-upload",
            "text": "The Intel hex file can be uploaded using the following command :  # Example (while under <top>/sim) :\nsudo ../jtag/nanorv32_jtag_uploader.py ../ctests/gpio_toggle_infinite/gpio_toggle_infinite.ihex -r  The  -r  option is used to force a reset after the code upload so that the CPU can start executing the code right away  Note the code update is actually very slow - This should be fix soon.  The pyftdi and intelhex Python modules  may need to be installed for the comman above to work properly :  sudo pip install pyftdi intelhex",
            "title": "Code upload"
        },
        {
            "location": "/#uart-output",
            "text": "An UART is implemented in the device and pins are routed to the ARTY7 onboard serial-to-usb converter.  To see the uart in action. compile the code with the -f option - this will replace the printf output through the verilog testbench by an output through the UART.  See the  /ctest/uart_simple  verification program for an example on how to access the uart through the prinft function.  # Example (while under <top>/sim) :\n./runtest.py    ../ctests/uart_simple -v -f -c\nsudo ../jtag/nanorv32_jtag_uploader.py ../ctests/uart_simple/uart_simple.ihex -r  Baudrate is set to 38400 for this example. To visualize the UART output using miniterm.py :  miniterm.py /dev/ttyUSB1 38400",
            "title": "UART output"
        },
        {
            "location": "/#simulation-using-vivado-outdated",
            "text": "",
            "title": "Simulation  using Vivado (outdated)"
        },
        {
            "location": "/#compilation",
            "text": "make xcomp\nmake xelab",
            "title": "Compilation"
        },
        {
            "location": "/#simulation-batch-mode",
            "text": "make xsim",
            "title": "Simulation (Batch mode)"
        },
        {
            "location": "/#simulation-gui",
            "text": "make xsim_gui",
            "title": "Simulation (GUI)"
        },
        {
            "location": "/#simulation-using-verilator",
            "text": "TBD",
            "title": "Simulation  using Verilator"
        }
    ]
}